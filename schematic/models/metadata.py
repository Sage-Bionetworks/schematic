import json
import logging

import pandas as pd
import networkx as nx
from jsonschema import Draft7Validator, exceptions, validate, ValidationError

# allows specifying explicit variable types
from typing import Any, Dict, Optional, Text, List

# handle schema logic; to be refactored as SchemaExplorer matures into a package
# as collaboration with Biothings progresses

from schematic.schemas.explorer import SchemaExplorer
from schematic.manifest.generator import ManifestGenerator
from schematic.schemas.generator import SchemaGenerator
from schematic.synapse.store import SynapseStorage
from schematic.utils.df_utils import trim_commas_df

class MetadataModel(object):
    """Metadata model wrapper around schema.org specification graph.
    
    Provides basic utilities to:

    1) manipulate the metadata model
    2) generate metadata model views:
        - generate manifest view of the metadata model
        - generate validation schema view of the metadata model
    """

    def __init__(self,
                inputMModelLocation: str,
                inputMModelLocationType: str,
                ) -> None:

        """Instantiates a MetadataModel object.

        Args:
            inputMModelLocation: local path, uri, synapse entity id (e.g. gs://, syn123, /User/x/â€¦); present location
            inputMModelLocationType: specifier to indicate where the metadata model resource can be found (e.g. 'local' if file/JSON-LD is on local machine)
        """
        # extract extension of 'inputMModelLocation'
        # ensure that it is necessarily pointing to a '.jsonld' file
        if inputMModelLocation.rpartition('.')[-1] == "jsonld":
            self.inputMModelLocation = inputMModelLocation

            self.sg = SchemaGenerator(inputMModelLocation)
        else:
            print("Can't create object of SchemaGenerator class. Please make sure the 'inputMModelLocation' argument is pointing to a JSON-LD file.")
            return

        # check if the type of MModel file is "local"
        # currently, the application only supports reading from local JSON-LD files
        if inputMModelLocationType == "local":
            self.inputMModelLocationType = inputMModelLocationType
        else:
            print("Please make sure to use a local JSON-LD file. 'InputMModelLocationType' must be 'local'.")
            return

    # business logic: expose metadata model "views" depending on "controller" logic
    # (somewhat analogous to Model View Controller pattern for GUI/web applications)
    # i.e. jsonschemas, annotation manifests, metadata/annotation dictionary web explorer
    # are all "views" of the metadata model.
    # The "business logic" in this MetadataModel class provides functions exposing relevant parts
    # of the metadata model needed so that these views can be generated by user facing components;
    # controller components are (loosely speaking) responsible for handling the interaction between views and the model
    # some of these components right now reside in the Bundle class

    def getModelSubgraph(self, rootNode: str, 
                        subgraphType: str) -> nx.DiGraph:
        """Gets a schema subgraph from rootNode descendants based on edge/node properties of type subgraphType.
        
        Args:
            rootNode: a schema node label (i.e. term).
            subgraphType: the kind of subgraph to traverse (i.e. based on node properties or edge labels).
        
        Returns:
            A directed subgraph (networkx DiGraph) of the metadata model with vertex set root node descendants.

        Raises: 
            ValueError: rootNode not found in metadata model.
        """
        pass

    def getOrderedModelNodes(self, rootNode: str, relationshipType: str) -> List[str]:
        """Get a list of model objects ordered by their topological sort rank in a model subgraph on edges of a given relationship type.

        Args:
            rootNode: a schema object/node label (i.e. term)
            relationshipType: edge label type of the schema subgraph (e.g. requiresDependency)
        
        Returns:
            An ordered list of objects, that are all descendants of rootNode.

        Raises: 
            ValueError: rootNode not found in metadata model.
        """
        ordered_nodes = self.sg.get_descendants_by_edge_type(rootNode, relationshipType, connected=True, ordered=True)

        ordered_nodes.reverse()

        return ordered_nodes

    
    def getModelManifest(self, title: str, rootNode: str, jsonSchema: str = None, filenames: list = None) -> str: 
        """Gets data from the annotations manifest file.

        TBD: Does this method belong here or in manifest generator?
        
        Args:
            rootNode: a schema node label (i.e. term).
        
        Returns:
            A manifest URI (assume Google doc for now).

        Raises: 
            ValueError: rootNode not found in metadata model.
        """
        additionalMetadata = {}
        if filenames:
            additionalMetadata["Filename"] = filenames

        try:
            mg = ManifestGenerator(title, self.inputMModelLocation, rootNode, additionalMetadata)
        except ValueError:
            print("rootNode not found in metadata model.")
            return
        except:
            print("There was a problem retrieving the manifest.")
            return

        if jsonSchema:
            return mg.get_manifest(jsonSchema)

        return mg.get_manifest()


    def get_component_requirements(self, source_component: str) -> List[str]:
        """Given a source model component (see https://w3id.org/biolink/vocab/category for definnition of component), return all components required by it.
        Useful to construct requirement dependencies not only between specific attributes but also between categories/components of attributes;
        Can be utilized to track metadata completion progress across multiple categories of attributes.
        
        Args: 
            source_component: an attribute label indicating the source component.

        Returns: 
            A list of required components associated with the source component.
        """ 
        # get metadata model schema graph
        # mm_graph = self.se.get_nx_schema()

        # get required components for the input/source component
        req_components = self.sg.get_component_requirements(source_component)
        # req_components = get_component_requirements(mm_graph, source_component) 

        return req_components


    # TODO: abstract validation in its own module
    def validateModelManifest(self, manifestPath: str, rootNode: str, jsonSchema: str = None) -> List[str]:     
        """Check if provided annotations manifest dataframe satisfies all model requirements.

        Args:
            rootNode: a schema node label (i.e. term).
            manifestPath: a path to the manifest csv file containing annotations.
        
        Returns:
            A validation status message; if there is an error the message.
            contains the manifest annotation record (i.e. row) that is invalid, along with the validation error associated with this record.
        
        Raises: 
            ValueError: rootNode not found in metadata model.
        """
        # get validation schema for a given node in the data model, if the user has not provided input validation schema
        if not jsonSchema:
            jsonSchema = self.sg.get_json_schema_requirements(rootNode, rootNode + "_validation")
         
        errors = []
        
        manifest = pd.read_csv(manifestPath)    # read manifest csv file as is from manifest path

        manifest = trim_commas_df(manifest).fillna("")  # apply cleaning logic as part of pre-processing step

        # handler for mismatched components/data types
        # throw TypeError if the value(s) in the "Component" column differ from the selected template type
        if ('Component' in manifest.columns) and (
            (len(manifest['Component'].unique()) > 1) or (manifest['Component'].unique()[0] != rootNode)
            ):
            logging.error(f"The 'Component' column value(s) {manifest['Component'].unique()} do not match the "
                          f"selected template type '{rootNode}'.")
            
            # row indexes for all rows where 'Component' is rootNode
            row_idxs = manifest.index[manifest['Component'] != rootNode].tolist()
            # column index value for the 'Component' column
            col_idx = manifest.columns.get_loc('Component')
            # Series with index and 'Component' values from manifest
            mismatched_ser = manifest.iloc[row_idxs, col_idx]
            for index, component in mismatched_ser.items():
                errors.append([
                    index + 2,
                    'Component',
                    f"Component value provided is: '{component}', whereas the Template Type is: '{rootNode}'",

                    # tuple of the component in the manifest and selected template type
                    # check: R/Reticulate cannnot handle dicts? So returning tuple
                    (component, rootNode)
                ])
                
            return errors


        """ 
        check if each of the provided annotation columns has validation rule 'list'
        if so, assume annotation for this column are comma separated list of multi-value annotations
        convert multi-valued annotations to list
        """
        for col in manifest.columns:
            
            # remove trailing/leading whitespaces from manifest
            manifest.applymap(lambda x: x.strip() if isinstance(x, str) else x)


            # convert manifest values to string
            # TODO: when validation handles annotation types as validation rules 
            # would have to avoid converting everything to string
            manifest[col] = manifest[col].astype(str)

            # if the validation rule is set to list, convert items in the
            # annotations manifest to a list and strip each value from leading/trailing spaces
            if "list" in self.sg.get_node_validation_rules(col): 
                manifest[col] = manifest[col].apply(lambda x: [s.strip() for s in str(x).split(",")])
                print(manifest[col])

        annotations = json.loads(manifest.to_json(orient='records'))
        print(annotations) 
        for i, annotation in enumerate(annotations):
            v = Draft7Validator(jsonSchema)

            for error in sorted(v.iter_errors(annotation), key=exceptions.relevance):
                errorRow = i + 2
                errorCol = error.path[-1] if len(error.path) > 0 else "Wrong schema" 
                errorMsg = error.message[0:500]
                errorVal = error.instance if len(error.path) > 0 else "Wrong schema"

                errors.append([errorRow, errorCol, errorMsg, errorVal])
                
        return errors


    def populateModelManifest(self, title, manifestPath: str, rootNode: str) -> str: 
        """Populate an existing annotations manifest based on a dataframe.
         
        Args:
            rootNode: a schema node label (i.e. term).
            manifestPath: a path to the manifest csv file containing annotations.
        
        Returns:
            A link to the filled in model manifest (e.g. google sheet).

        Raises: 
            ValueError: rootNode not found in metadata model.
        """
        mg = ManifestGenerator(title, self.inputMModelLocation, rootNode)
        
        emptyManifestURL = mg.get_manifest()

        return mg.populate_manifest_spreadsheet(manifestPath, emptyManifestURL)
